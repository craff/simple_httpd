{0 Simple_httpd library to write web server and application}

This library implements a HTTP/1.1 server for Linux using domains and
algebraic effect. It uses [epoll] and [eventfd] to schedule the treatment of
clients efficiently, with one domain used to accept request and several
domains to handle these requests. ̀Simple_httpd` can listen to several adresses
and ports and use this information together with the headers `Host` field to
decide how to answer the request. It is relatively fast and can handle
thousands of simultaneous connections, because if uses then `sendfile` system
call and other TCP options to gain efficiency.

 ̀Simple_httpd` provides:

- Routing with function to add route
- Handling of static files possibly using a memory cache or a virtual file system.
- Basic managment of session and cookies
- Support for ssl
- A {!Simple_httpd.Host} module dedicated to write single server handling several sites
- A {{:./vfs_pack.html} web site compiler `vfs_pack`}, which includes an equivalent
  of php files that are compiled to OCaml.

Here are some curves showing the performance on static files compared to nginx and
apache:

{%html: <p align="center"><img src="https://raffalli.eu/simple_httpd/small.png" alt="comparison for small files"/></p>%}

{%html: <p align="center"><img src="https://raffalli.eu/simple_httpd/big.png" alt="comparison for large files"/></p>%}

And an histogram showing the difference between [.php] and [.chaml] on a similar file:

This is obtained using {{:https://github.com/tsenart/vegeta} vegeta} with 1000 request per seconds for 2 minutes. It is worst noticing the stability of [Simple_httpd] compared to [php]. Here is the result with [Simple_httpd] and [vfs_pack]:
{[
Bucket           #      %       Histogram
[0s,     100µs]  1      0.00%
[100µs,  200µs]  3638   3.03%   ##
[200µs,  300µs]  49683  41.40%  ###############################
[300µs,  400µs]  61175  50.98%  ######################################
[400µs,  500µs]  3780   3.15%   ##
[500µs,  750µs]  1469   1.22%
[750µs,  1ms]    195    0.16%
[1ms,    2ms]    56     0.05%
[2ms,    3ms]    0      0.00%
[3ms,    4ms]    3      0.00%
[4ms,    +Inf]    0      0.00%
]}
And a similar php files using the standard configuration of php 8.2 and apache under debian 12:
{[
Bucket           #      %       Histogram
[0s,     100µs]  0      0.00%
[100µs,  200µs]  0      0.00%
[200µs,  300µs]  0      0.00%
[300µs,  400µs]  66     0.06%
[400µs,  500µs]  2159   1.80%   #
[500µs,  750µs]  25837  21.53%  ################
[750µs,  1ms]    77554  64.63%  ################################################
[1ms,    2ms]    11554  9.63%   #######
[2ms,    3ms]    444    0.37%
[3ms,    4ms]    204    0.17%
[4ms,    5ms]    179    0.15%
[5ms,    +Inf]   2003   1.67%   #

]}

See [examples/echo.ml] below, that demonstrates some of the features by
declaring a few endpoints, including one for uploading files and a virtual
file system.

To go further, you should start reading {!Simple_httpd} the main module of the library.

{[
(* echo.ml: a fairly complete example *)
open Simple_httpd
module H = Headers

let now = Unix.gettimeofday

(** add a missing [add_float] function to Atomic *)
module Atomic = struct
  include Atomic
  let add_float a x =
    let fn () =
      let v = Atomic.get a in
      Atomic.compare_and_set a v (v +. x)
    in
    while not (fn ()) do () done;
end

(** [Simple_httpd] provides filter for request, that can be used to collecting
    statistics. Currently, we can not count the time to output the response. *)
let filter_stat () : 'a Route.filter * (unit -> string) =
  (* We must use atomic for this to work with domains! *)
  let nb_req     = Atomic.make 0  in
  let total_time = Atomic.make 0. in
  let parse_time = Atomic.make 0. in
  let build_time = Atomic.make 0. in

  let measure req =
    Atomic.incr nb_req;
    let t1 = Request.start_time req in
    let t2 = now () in
    (req, fun response ->
        let t3 = now () in
        Atomic.add_float total_time (t3 -. t1);
        Atomic.add_float parse_time (t2 -. t1);
        Atomic.add_float build_time (t3 -. t2);
        response)
  and get_stat () =
    let nb = Atomic.get nb_req in
    Printf.sprintf "%d requests (average response time: %.3fms = %.3fms + %.3fms)"
      nb (Atomic.get total_time /. float nb *. 1e3)
         (Atomic.get parse_time /. float nb *. 1e3)
         (Atomic.get build_time /. float nb *. 1e3)
  in
  (measure, get_stat)

(** Parse command line options *)

(** default address, port and maximum number of connections *)
let addr = ref "127.0.0.1"
let port = ref 8080
let top_dir = ref None

(** Server.args provides a bunch and standard option to control the
    maximum number of connections, logs, etc... *)
let args, parameters = Server.args ()
let _ =
  Arg.parse (Arg.align ([
      "--addr", Arg.Set_string addr, " set address";
      "-a", Arg.Set_string addr, " set address";
      "--port", Arg.Set_int port, " set port";
      "-p", Arg.Set_int port, " set port";
      "--dir", Arg.String (fun s -> top_dir := Some s), " set the top dir for file path";
    ] @ args)) (fun _ -> raise (Arg.Bad "")) "echo [option]*"

(** Server initialisation *)
let listens = [Address.make ~addr:!addr ~port:!port ()]
let server = Server.create parameters ~listens

(** Compose the above filter with the compression filter
    provided by [Simple_httpd.Camlzip], than will compress output
    when [deflate] is accepted *)
let filter, get_stats =
  let filter_stat, get_stats = filter_stat () in
  let filter_zip =
    Camlzip.filter ~compress_above:1024 ~buf_size:(16*1024) () in
  (Route.compose_cross filter_zip filter_stat, get_stats)

(** Add a route answering 'Hello world' to [http://localhost/hello/world] *)
let _ =
  Server.add_route_handler ~meth:GET server ~filter
    Route.(exact "hello" @/ string @/ return)
    (fun name _req -> Response.make_string ("hello " ^name ^"!\n"))

(** Add a route sending a compressed stream for the given file in the current
    directory *)
let _ =
  Server.add_route_handler ~meth:GET server ~filter
    Route.(exact "zcat" @/ string @/ return)
    (fun path _req ->
        let ic = open_in path in
        let str = Input.of_chan ic in
        let mime_type =
          try
            let p = Unix.open_process_in (Printf.sprintf "file -i -b %S" path) in
            try
              let s = [H.Content_Type, String.trim (input_line p)] in
              ignore @@ Unix.close_process_in p;
              s
            with _ -> ignore @@ Unix.close_process_in p; []
          with _ -> []
        in
        Response.make_stream ~headers:mime_type str
      )

(** Add an echo request *)
let _ =
  Server.add_route_handler server ~filter
    Route.(exact "echo" @/ return)
    (fun req ->
      let q =
        Request.query req |> List.map (fun (k,v) -> Printf.sprintf "%S = %S" k v)
        |> String.concat ";"
      in
      Response.make_string
        (Format.asprintf "echo:@ %a@ (query: %s)@." Request.pp req q))

(** Add file upload *)
let _ =
  Server.add_route_handler_stream ~meth:PUT server ~filter
    Route.(exact "upload" @/ string @/ return)
    (fun path req ->
        Log.f (fun k->k "start upload %S, headers:\n%s\n\n%!" path
                     (Format.asprintf "%a" Headers.pp (Request.headers req)));
        try
          let oc = open_out @@ "/tmp/" ^ path in
          Input.to_chan oc (Request.body req);
          flush oc;
          Response.make_string "uploaded file"
        with e ->
          Response.fail ~code:500 "couldn't upload file: %s" (Printexc.to_string e)
      )

(** Access to the statistics *)
let _ =
  Server.add_route_handler server ~filter Route.(exact "stats" @/ return)
    (fun _req ->
       let stats = get_stats() in
       Response.make_string stats
    )

(** Add a virtual file system VFS, produced by [simple-httpd-vfs-pack] from
    an actual folger *)
let _ =
  let vfs = Vfs.make ?top_dir:!top_dir () in
  Dir.add_vfs server
    ~config:(Dir.config ~download:true
               ~dir_behavior:Dir.Index_or_lists ())
    ~vfs:vfs ~prefix:"vfs"

(** Main pagen using the Html module (deprecated by vfs_pack and many other solutions *)
let _ =
  Server.add_route_handler server ~filter Route.return
    (fun _req ->
       let open Html in
       let h = html [] [
           head[][title[][txt "index of echo"]];
           body[][
             h3[] [txt "welcome!"];
             p[] [b[] [txt "endpoints are:"]];
             ul[] [
               li[][pre[][txt "/hello/:name (GET)"]];
               li[][pre[][a[A.href "/echo/"][txt "echo"]; txt " echo back query"]];
               li[][pre[][txt "/upload/:path (PUT) to upload a file"]];
               li[][pre[][txt "/zcat/:path (GET) to download a file (deflate transfer-encoding)"]];
               li[][pre[][a[A.href "/stats/"][txt"/stats/"]; txt" (GET) to access statistics"]];
               li[][pre[][a[A.href "/vfs/"][txt"/vfs"]; txt" (GET) to access a VFS embedded in the binary"]];
             ]
           ]
         ] in
       let s = to_string ~top:true h in
       Response.make_string ~headers:[H.Content_Type, "text/html"] s)

(** Output a message before starting the server *)
let _ =
  Array.iter (fun l ->
    let open Address in
    Printf.printf "listening on http://%s:%d\n%!" l.addr l.port) (Server.listens server)

(** Start the server *)
let _ =
  Server.run server
]}
