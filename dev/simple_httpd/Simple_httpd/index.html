<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Simple_httpd (simple_httpd.Simple_httpd)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">simple_httpd</a> &#x00BB; Simple_httpd</nav><header class="odoc-preamble"><h1>Module <code><span>Simple_httpd</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#http-server">Http Server</a><ul><li><a href="#tiny-buffer-implementation">Tiny buffer implementation</a></li><li><a href="#generic-stream-of-data">Generic stream of data</a></li><li><a href="#main-server-type">Main Server Type</a><ul><li><a href="#methods">Methods</a></li><li><a href="#headers">Headers</a></li><li><a href="#requests">Requests</a></li><li><a href="#response-codes">Response Codes</a></li><li><a href="#responses">Responses</a></li><li><a href="#main-server-type_2">Main Server type</a></li><li><a href="#request-handlers">Request handlers</a></li><li><a href="#server-sent-events">Server-sent events</a></li><li><a href="#run-the-server">Run the server</a></li></ul></li><li><a href="#utils">Utils</a></li><li><a href="#static-directory-serving">Static directory serving</a></li><li><a href="#cooperative-threading">cooperative threading</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="http-server"><a href="#http-server" class="anchor"></a>Http Server</h2><p>This library implements a very simple, basic HTTP/1.1 server using blocking IOs and threads. Basic routing based on <code>Scanf</code> is provided for convenience, so that several handlers can be registered.</p><p>It is possible to use a thread pool, see <a href="#val-create"><code>create</code></a>'s argument <code>new_thread</code>.</p><p>The <code>echo</code> example (see <code>src/examples/echo.ml</code>) demonstrates some of the features by declaring a few endpoints, including one for uploading files:</p><pre class="language-ocaml"><code>module S = Simple_httpd

let () =
  let server = S.create () in

  (* say hello *)
  S.add_route_handler ~meth:`GET server
    S.Route.(exact &quot;hello&quot; @/ string @/ return)
    (fun name _req -&gt; S.Response.make_string (Ok (&quot;hello &quot; ^name ^&quot;!\n&quot;)));

  (* echo request *)
  S.add_route_handler server
    S.Route.(exact &quot;echo&quot; @/ return)
    (fun req -&gt; S.Response.make_string
        (Ok (Format.asprintf &quot;echo:@ %a@.&quot; S.Request.pp req)));

  (* file upload *)
  S.add_route_handler ~meth:`PUT server
    S.Route.(exact &quot;upload&quot; @/ string_urlencoded @/ return)
    (fun path req -&gt;
        try
          let oc = open_out @@ &quot;/tmp/&quot; ^ path in
          output_string oc req.S.Request.body;
          flush oc;
          S.Response.make_string (Ok &quot;uploaded file&quot;)
        with e -&gt;
          S.Response.fail ~code:500 &quot;couldn't upload file: %s&quot;
            (Printexc.to_string e)
      );

  (* run the server *)
  Printf.printf &quot;listening on http://%s:%d\n%!&quot; (S.addr server) (S.port server);
  match S.run server with
  | Ok () -&gt; ()
  | Error e -&gt; raise e</code></pre><p>It is then possible to query it using curl:</p><pre class="language-ocaml"><code>$ dune exec src/examples/echo.exe &amp;
listening on http://127.0.0.1:8080

# the path &quot;hello/name&quot; greets you.
$ curl -X GET http://localhost:8080/hello/quadrarotaphile
hello quadrarotaphile!

# the path &quot;echo&quot; just prints the request.
$ curl -X GET http://localhost:8080/echo --data &quot;howdy y'all&quot;
echo:
{meth=GET;
 headers=Host: localhost:8080
         User-Agent: curl/7.66.0
         Accept: */*
         Content-Length: 10
         Content-Type: application/x-www-form-urlencoded;
 path=&quot;/echo&quot;; body=&quot;howdy y'all&quot;}</code></pre><h3 id="tiny-buffer-implementation"><a href="#tiny-buffer-implementation" class="anchor"></a>Tiny buffer implementation</h3><p>These buffers are used to avoid allocating too many byte arrays when processing streams and parsing requests.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Buf"><a href="#module-Buf" class="anchor"></a><code><span><span class="keyword">module</span> Buf</span><span> = <a href="../Simple_httpd_buf/index.html">Simple_httpd_buf</a></span></code></div></div><h3 id="generic-stream-of-data"><a href="#generic-stream-of-data" class="anchor"></a>Generic stream of data</h3><p>Streams are used to represent a series of bytes that can arrive progressively. For example, an uploaded file will be sent as a series of chunks.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Byte_stream"><a href="#module-Byte_stream" class="anchor"></a><code><span><span class="keyword">module</span> Byte_stream</span><span> = <a href="../Simple_httpd_stream/index.html">Simple_httpd_stream</a></span></code></div></div><h3 id="main-server-type"><a href="#main-server-type" class="anchor"></a>Main Server Type</h3><div class="odoc-spec"><div class="spec type anchored" id="type-buf"><a href="#type-buf" class="anchor"></a><code><span><span class="keyword">type</span> buf</span><span> = <a href="../Simple_httpd_buf/index.html#type-t">Simple_httpd_buf.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-byte_stream"><a href="#type-byte_stream" class="anchor"></a><code><span><span class="keyword">type</span> byte_stream</span><span> = <a href="../Simple_httpd_stream/index.html#type-t">Simple_httpd_stream.t</a></span></code></div></div><h5 id="methods"><a href="#methods" class="anchor"></a>Methods</h5><div class="odoc-spec"><div class="spec module anchored" id="module-Meth"><a href="#module-Meth" class="anchor"></a><code><span><span class="keyword">module</span> Meth</span><span> = <a href="../Simple_httpd_server/Meth/index.html">Simple_httpd_server.Meth</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Cookies"><a href="#module-Cookies" class="anchor"></a><code><span><span class="keyword">module</span> Cookies</span><span> = <a href="../Simple_httpd_server/Cookies/index.html">Simple_httpd_server.Cookies</a></span></code></div></div><h5 id="headers"><a href="#headers" class="anchor"></a>Headers</h5><p>Headers are metadata associated with a request or response.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Headers"><a href="#module-Headers" class="anchor"></a><code><span><span class="keyword">module</span> Headers</span><span> = <a href="../Simple_httpd_server/Headers/index.html">Simple_httpd_server.Headers</a></span></code></div></div><h5 id="requests"><a href="#requests" class="anchor"></a>Requests</h5><p>Requests are sent by a client, e.g. a web browser or cURL.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Request"><a href="#module-Request" class="anchor"></a><code><span><span class="keyword">module</span> Request</span><span> = <a href="../Simple_httpd_server/Request/index.html">Simple_httpd_server.Request</a></span></code></div></div><h5 id="response-codes"><a href="#response-codes" class="anchor"></a>Response Codes</h5><div class="odoc-spec"><div class="spec module anchored" id="module-Response_code"><a href="#module-Response_code" class="anchor"></a><code><span><span class="keyword">module</span> Response_code</span><span> = <a href="../Simple_httpd_server/Response_code/index.html">Simple_httpd_server.Response_code</a></span></code></div></div><h5 id="responses"><a href="#responses" class="anchor"></a>Responses</h5><p>Responses are what a http server, such as <a href="#"><code>Simple_httpd</code></a>, send back to the client to answer a <a href="../Simple_httpd_server/Request/index.html#type-t"><code>Request.t</code></a></p><div class="odoc-spec"><div class="spec module anchored" id="module-Response"><a href="#module-Response" class="anchor"></a><code><span><span class="keyword">module</span> Response</span><span> = <a href="../Simple_httpd_server/Response/index.html">Simple_httpd_server.Response</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Route"><a href="#module-Route" class="anchor"></a><code><span><span class="keyword">module</span> Route</span><span> = <a href="../Simple_httpd_server/Route/index.html">Simple_httpd_server.Route</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Middleware"><a href="#module-Middleware" class="anchor"></a><code><span><span class="keyword">module</span> Middleware</span><span> = <a href="../Simple_httpd_server/Middleware/index.html">Simple_httpd_server.Middleware</a></span></code></div></div><h5 id="main-server-type_2"><a href="#main-server-type_2" class="anchor"></a>Main Server type</h5><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../Simple_httpd_server/index.html#type-t">Simple_httpd_server.t</a></span></code></div><div class="spec-doc"><p>A HTTP server. See <a href="#val-create"><code>create</code></a> for more details.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span>?masksigpipe:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?max_connections:int <span class="arrow">&#45;&gt;</span></span>
  <span>?granularity:int <span class="arrow">&#45;&gt;</span></span>
  <span>?num_thread:int <span class="arrow">&#45;&gt;</span></span>
  <span>?timeout:float <span class="arrow">&#45;&gt;</span></span>
  <span>?buf_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>?get_time_s:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> float)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?listens:<span><a href="../Simple_httpd_domain/index.html#type-listenning">Simple_httpd_domain.listenning</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?middlewares:<span><span>(<span>[ `Encoding <span><span>| `Stage</span> of int</span> ]</span> * <a href="../Simple_httpd_server/Middleware/index.html#type-t">Middleware.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a new webserver.</p><p>The server will not do anything until <a href="#val-run"><code>run</code></a> is called on it. Before starting the server, one can use <code>add_path_handler</code> and <a href="#val-set_top_handler"><code>set_top_handler</code></a> to specify how to handle incoming requests.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">masksigpipe</span> <p>if true, block the signal <code>Sys</code>.sigpipe which otherwise tends to kill client threads when they try to write on broken sockets. Default: <code>true</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">buf_size</span> <p>size for buffers (since 0.11)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">middlewares</span> <p>see <a href="#val-add_middleware"><code>add_middleware</code></a> for more details.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_connections</span> <p>maximum number of simultaneous connections.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">granularity</span> <p>yield every granularity read or write.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">num_thread</span> <p>number of thread to treat client.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">timeout</span> <p>connection is closed if the socket does not do read or write for the amount of second. Default: 0.0 which means no timeout. timeout is not recommended when using proxy.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">addr</span> <p>address (IPv4 or IPv6) to listen on. Default <code>&quot;127.0.0.1&quot;</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">port</span> <p>to listen on. Default <code>8080</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">sock</span> <p>an existing socket given to the server to listen on, e.g. by systemd on Linux (or launchd on macOS). If passed in, this socket will be used instead of the <code>addr</code> and <code>port</code>. If not passed in, those will be used. This parameter exists since 0.10.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">get_time_s</span> <p>obtain the current timestamp in seconds. This parameter exists since 0.11.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-listens"><a href="#val-listens" class="anchor"></a><code><span><span class="keyword">val</span> listens : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Simple_httpd_domain/index.html#type-listenning">Simple_httpd_domain.listenning</a> list</span></span></code></div><div class="spec-doc"><p>Addresses and ports on which the server listens.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-active_connections"><a href="#val-active_connections" class="anchor"></a><code><span><span class="keyword">val</span> active_connections : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Number of active connections</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_decode_request_cb"><a href="#val-add_decode_request_cb" class="anchor"></a><code><span><span class="keyword">val</span> add_decode_request_cb : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>unit <a href="../Simple_httpd_server/Request/index.html#type-t">Request.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <a href="../Simple_httpd_server/Request/index.html#type-t">Request.t</a></span> * <span>(<span><a href="#type-byte_stream">byte_stream</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-byte_stream">byte_stream</a>)</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add a callback for every request. The callback can provide a stream transformer and a new request (with modified headers, typically). A possible use is to handle decompression by looking for a <code>Transfer-Encoding</code> header and returning a stream transformer that decompresses on the fly.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>use <a href="#val-add_middleware"><code>add_middleware</code></a> instead</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_encode_response_cb"><a href="#val-add_encode_response_cb" class="anchor"></a><code><span><span class="keyword">val</span> add_encode_response_cb : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>unit <a href="../Simple_httpd_server/Request/index.html#type-t">Request.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Simple_httpd_server/Response/index.html#type-t">Response.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Simple_httpd_server/Response/index.html#type-t">Response.t</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add a callback for every request/response pair. Similarly to <a href="#val-add_encode_response_cb"><code>add_encode_response_cb</code></a> the callback can return a new response, for example to compress it. The callback is given the query with only its headers, as well as the current response.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>use <a href="#val-add_middleware"><code>add_middleware</code></a> instead</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_middleware"><a href="#val-add_middleware" class="anchor"></a><code><span><span class="keyword">val</span> add_middleware : 
  <span>stage:<span>[ `Encoding <span><span>| `Stage</span> of int</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Simple_httpd_server/Middleware/index.html#type-t">Middleware.t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add a middleware to every request/response pair.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">stage</span> <p>specify when middleware applies. Encoding comes first (outermost layer), then stages in increasing order.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if stage is <code>`Stage n</code> where <code>n &lt; 1</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><h5 id="request-handlers"><a href="#request-handlers" class="anchor"></a>Request handlers</h5><div class="odoc-spec"><div class="spec value anchored" id="val-set_top_handler"><a href="#val-set_top_handler" class="anchor"></a><code><span><span class="keyword">val</span> set_top_handler : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>string <a href="../Simple_httpd_server/Request/index.html#type-t">Request.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Simple_httpd_server/Response/index.html#type-t">Response.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Setup a handler called by default.</p><p>This handler is called with any request not accepted by any handler installed via <code>add_path_handler</code>. If no top handler is installed, unhandled paths will return a <code>404</code> not found.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-finaliser"><a href="#type-finaliser" class="anchor"></a><code><span><span class="keyword">type</span> finaliser</span><span> = <span><a href="../Simple_httpd_server/Response/index.html#type-t">Response.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Simple_httpd_server/Response/index.html#type-t">Response.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-accept"><a href="#type-accept" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a accept</span></span><span> =
  <span><span><span class="type-var">'a</span> <a href="../Simple_httpd_server/Request/index.html#type-t">Request.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-finaliser">finaliser</a>, <a href="../Simple_httpd_server/Response_code/index.html#type-t">Response_code.t</a> * string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_route_handler"><a href="#val-add_route_handler" class="anchor"></a><code><span><span class="keyword">val</span> add_route_handler : 
  <span>?accept:<span>unit <a href="#type-accept">accept</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?middlewares:<span><a href="../Simple_httpd_server/Middleware/index.html#type-t">Middleware.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?meth:<a href="../Simple_httpd_server/Meth/index.html#type-t">Meth.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span><span>string <a href="../Simple_httpd_server/Request/index.html#type-t">Request.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Simple_httpd_server/Response/index.html#type-t">Response.t</a>)</span> <a href="../Simple_httpd_server/Route/index.html#type-t">Route.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>add_route_handler server Route.(exact &quot;path&quot; @/ string @/ int @/ return) f</code> calls <code>f &quot;foo&quot; 42 request</code> when a <code>request</code> with path &quot;path/foo/42/&quot; is received.</p><p>Note that the handlers are called in the reverse order of their addition, so the last registered handler can override previously registered ones.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">meth</span> <p>if provided, only accept requests with the given method. Typically one could react to <code>`GET</code> or <code>`PUT</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">accept</span> <p>should return <code>Ok fn</code> if the given request (before its body is read) should be accepted, <code>Error (code,message)</code> if it's to be rejected (e.g. because. <code>fn: finaliser</code> is used to transform the response. its content is too big, or for some permission error). See the <code>http_of_dir</code> program for an example of how to use <code>accept</code> to filter uploads that are too large before the upload even starts. The default always returns <code>Ok()</code>, i.e. it accepts all requests.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.6</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_route_handler_stream"><a href="#val-add_route_handler_stream" class="anchor"></a><code><span><span class="keyword">val</span> add_route_handler_stream : 
  <span>?accept:<span>unit <a href="#type-accept">accept</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?middlewares:<span><a href="../Simple_httpd_server/Middleware/index.html#type-t">Middleware.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?meth:<a href="../Simple_httpd_server/Meth/index.html#type-t">Meth.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span><span><a href="#type-byte_stream">byte_stream</a> <a href="../Simple_httpd_server/Request/index.html#type-t">Request.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Simple_httpd_server/Response/index.html#type-t">Response.t</a>)</span> <a href="../Simple_httpd_server/Route/index.html#type-t">Route.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Similar to <a href="#val-add_route_handler"><code>add_route_handler</code></a>, but where the body of the request is a stream of bytes that has not been read yet. This is useful when one wants to stream the body directly into a parser, json decoder (such as <code>Jsonm</code>) or into a file.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.6</li></ul></div></div><h5 id="server-sent-events"><a href="#server-sent-events" class="anchor"></a>Server-sent events</h5><p><b>EXPERIMENTAL</b>: this API is not stable yet.</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-SERVER_SENT_GENERATOR"><a href="#module-type-SERVER_SENT_GENERATOR" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> SERVER_SENT_GENERATOR</span><span> = <a href="../Simple_httpd_server/module-type-SERVER_SENT_GENERATOR/index.html">Simple_httpd_server.SERVER_SENT_GENERATOR</a></span></code></div><div class="spec-doc"><p>A server-side function to generate of Server-sent events.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-server_sent_generator"><a href="#type-server_sent_generator" class="anchor"></a><code><span><span class="keyword">type</span> server_sent_generator</span><span> = <span>(<span class="keyword">module</span> <a href="module-type-SERVER_SENT_GENERATOR/index.html">SERVER_SENT_GENERATOR</a>)</span></span></code></div><div class="spec-doc"><p>Server-sent event generator</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_route_server_sent_handler"><a href="#val-add_route_server_sent_handler" class="anchor"></a><code><span><span class="keyword">val</span> add_route_server_sent_handler : 
  <span>?accept:<span>unit <a href="#type-accept">accept</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span><span>string <a href="../Simple_httpd_server/Request/index.html#type-t">Request.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-server_sent_generator">server_sent_generator</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <a href="../Simple_httpd_server/Route/index.html#type-t">Route.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add a handler on an endpoint, that serves server-sent events.</p><p>The callback is given a generator that can be used to send events as it pleases. The connection is always closed by the client, and the accepted method is always <code>GET</code>. This will set the header &quot;content-type&quot; to &quot;text/event-stream&quot; automatically and reply with a 200 immediately. See <a href="#type-server_sent_generator"><code>server_sent_generator</code></a> for more details.</p><p>This handler stays on the original thread (it is synchronous).</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><h5 id="run-the-server"><a href="#run-the-server" class="anchor"></a>Run the server</h5><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Run the main loop of the server, listening on a socket described at the server's creation time, using <code>new_thread</code> to start a thread for each new client.</p><p>This returns <code>Ok ()</code> if the server exits gracefully, or <code>Error e</code> if it exits with an error.</p></div></div><h3 id="utils"><a href="#utils" class="anchor"></a>Utils</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Util"><a href="#module-Util" class="anchor"></a><code><span><span class="keyword">module</span> Util</span><span> = <a href="../Simple_httpd_util/index.html">Simple_httpd_util</a></span></code></div></div><h3 id="static-directory-serving"><a href="#static-directory-serving" class="anchor"></a>Static directory serving</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Dir"><a href="#module-Dir" class="anchor"></a><code><span><span class="keyword">module</span> Dir</span><span> = <a href="../Simple_httpd_dir/index.html">Simple_httpd_dir</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Html"><a href="#module-Html" class="anchor"></a><code><span><span class="keyword">module</span> Html</span><span> = <a href="../Simple_httpd_html/index.html">Simple_httpd_html</a></span></code></div><div class="spec-doc"><p>Alias to <a href="../Simple_httpd_html/index.html"><code>Simple_httpd_html</code></a></p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Domain"><a href="#module-Domain" class="anchor"></a><code><span><span class="keyword">module</span> Domain</span><span> = <a href="../Simple_httpd_domain/index.html">Simple_httpd_domain</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Session"><a href="#module-Session" class="anchor"></a><code><span><span class="keyword">module</span> Session</span><span> = <a href="../Simple_httpd_session/index.html">Simple_httpd_session</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-listenning"><a href="#type-listenning" class="anchor"></a><code><span><span class="keyword">type</span> listenning</span><span> = <a href="../Simple_httpd_domain/index.html#type-listenning">Simple_httpd_domain.listenning</a></span><span> = </span><span>{</span></code><ol><li id="type-listenning.addr" class="def record field anchored"><a href="#type-listenning.addr" class="anchor"></a><code><span>addr : string;</span></code></li><li id="type-listenning.port" class="def record field anchored"><a href="#type-listenning.port" class="anchor"></a><code><span>port : int;</span></code></li><li id="type-listenning.ssl" class="def record field anchored"><a href="#type-listenning.ssl" class="anchor"></a><code><span>ssl : <span><span class="xref-unresolved">Ssl</span>.context option</span>;</span></code></li></ol><code><span>}</span></code></div></div><p>usefull type</p><h3 id="cooperative-threading"><a href="#cooperative-threading" class="anchor"></a>cooperative threading</h3><p>The following functions deals with cooperative multi-tasking on each domain. First, recall that the OS will choose via <code>select</code> on which domain you serve your client, and after that, it is impossible for a job to change domain. This is a current limitation of domain with OCaml 5.0.</p><p>Then, on each domain, priority is based on arrival time: first arrived, first to run. With one exception: Mutexes have the highest priority, and among mutexes, the highest priority is again, first arrived, first to run.</p><p>If you want to have mutex with lower priority, you may do: <code> yield (); lock m </code> or <code> if not (Mutex.try_lock m) then (yield (); lock m)</code></p><p>This should more or less give a priority for mutexes comparable to other scheduled jobs... With more risk of deadlock ?</p><p>Normally context switching occurs when read or write is blocked in the socket serving the client or regularly (based on granularity parameter)</p><div class="odoc-spec"><div class="spec value anchored" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>let other thread run. Should be called for treatment that take time before sending results or reading data and when the other primitive can not be used. This happends typically for a pure computing task. Other solutions exists for instance for database request.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sleep"><a href="#val-sleep" class="anchor"></a><code><span><span class="keyword">val</span> sleep : <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as above, but with a minimum sleeping time in second</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Closed"><a href="#exception-Closed" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Closed</span> <span class="keyword">of</span> bool</span></code></div><div class="spec-doc"><p>exception used by the two functions below</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Io"><a href="#module-Io" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Io/index.html">Io</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module with function similar to Unix.read and Unix.single_write but that will perform scheduling</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-schedule_read"><a href="#val-schedule_read" class="anchor"></a><code><span><span class="keyword">val</span> schedule_read : <span><span class="xref-unresolved">Unix</span>.file_descr <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>schedule_read sock action close</code> should be called when a non blocking read operation would have blocked. When read become possible, <code>action ()</code> will be called. If it raises an exception <code>exn</code>, <code>close exn</code> will be called it is up to the user to decide of closing the socket and/or reraise the exception.</p><p>The return value should be (if possible) the number of bytes read. It this is meaningless, return a non zero value if some progress was made, while returning 0 will call <code>close (Closed true)</code>.</p><p>A typical application for this is when interacting with a data base in non blocking mode. For just reading a file or socket, use the Io module above.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-schedule_write"><a href="#val-schedule_write" class="anchor"></a><code><span><span class="keyword">val</span> schedule_write : <span><span class="xref-unresolved">Unix</span>.file_descr <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>schedule_read sock action close</code> is similar as above for a write operation. If it return <code>action ()</code> return 0; <code>close (Closed false)</code> is called.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lock"><a href="#val-lock" class="anchor"></a><code><span><span class="keyword">val</span> lock : <span><span class="xref-unresolved">Stdlib</span>.Mutex.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></div></body></html>